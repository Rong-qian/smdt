###############################################################################
#   File: legacy.py
#   Author(s): Dravin Flores, Paul Johnecheck
#   Date Created: 16 April, 2021
#
#   Purpose: Provides functions for legacy support. Currently, the database is stored as a list of dictionaries. This
#       file houses all of the necessary information to go from a list of
#       dictionaries to a list of tube objects, as well as go backwards and do the inverse operation.
#       
#
#   Known Issues:
#
#   Workarounds:
#
#   Updates:
#   2023-06 Rongqian Qian and Reinhard Schwienhorst: update for mini tubes
#   2023-07 Rongqian Qian: fix the bug of skipping reading csv file that saves the dark current record
#
###############################################################################


import os
import sys
import pickle
import datetime
import random

################
# If running on short tube, set Minitube to be True.
################


from .mini_tube import Mini_tube
from .data.swage import Swage, SwageRecord
from .data.tension import Tension, TensionRecord
from .data.leak import Leak, LeakRecord
from .data.dark_current import DarkCurrent, DarkCurrentRecord
from .data.position import Position, PositionRecord
from .data.umich import UMich_Tension, UMich_TensionRecord
from .data.umich import UMich_DarkCurrent, UMich_DarkCurrentRecord
from .data.umich import UMich_Bent, UMich_BentRecord
from .data.umich import UMich_Misc, UMich_MiscRecord
from .data.bent import Bent, BentRecord
from .data.status import ErrorCodes


class station_pickler:
    '''
    This class is designed to facilitate the interface between the database manager and the data generated by the
    stations. This class will take whatever data is generated in the form of a csv file, and will read it into a sMDT
    tube object. It will then pickle the object into the standard specified for new data for the db manager.
    '''

    sMDT_DIR = os.path.dirname(os.path.abspath(__file__))
    
    def __init__(self, path, archive=True, logging=True):
        '''
        Constructor, builds the pickler object. Gets the path to the directory it should look for/create the relevant
        files in
        '''
        self.path = path
        self.archive = archive
        self.error_files = {'Swage': set(), 'Tension': set(), 'Leak': set(), 'DarkCurrent': set(), 'Bentness': set(), 'Position': set()}
        self.logging = logging

    def write_errors(self):
        fp = open("errors.txt", 'a')
        for station in self.error_files:
            if self.error_files[station]:
                fp.write(station + ':\n')
                for filename in self.error_files[station]:
                    fp.write('\t' + filename + '\n')
        fp.close()

    '''
    This is the swage pickler function that will pickle every 
    swage csv file that is in the specified directory swagerDirectory
    '''

    def pickle_swage(self):
        swage_directory = os.path.join(self.path, "SwagerStation")
        CSV_directory = os.path.join(swage_directory, "SwagerData")
        for directory in [swage_directory, CSV_directory]:
            if not os.path.isdir(directory):
                # input directories don't exist, just return
                return                
        archive_directory = os.path.join(swage_directory, "archive")
        new_data_directory = os.path.join(self.sMDT_DIR, "new_data")

        for directory in [archive_directory, new_data_directory]:
            if not os.path.isdir(directory):
                os.mkdir(directory)

        for filename in os.listdir(CSV_directory):
            # skip directories
            if os.path.isdir(filename):
                   continue
            # skip .DS_store
            if filename==".DS_Store":
                continue
            with open(os.path.join(CSV_directory, filename)) as CSV_file:
                if self.archive:
                    archive_file = open(os.path.join(archive_directory, filename), 'a')
                for line in CSV_file.readlines():
                    if self.archive:
                        archive_file.write(line)
                    line = line.split(',')
                    # Here are the different csv types, there have been 3 versions
                    # The currently used version that includes endplug type 'Protvino' or 'Munich'
                    endplug_type = None
                    if len(line) not in [9, 8, 3]:
                        self.error_files['Swage'].add(filename)
                        continue
                    if len(line) == 9:
                        barcode = line[0].replace('\r', '').replace('\n', '')
                        raw_length = float(line[1]) if line[1] != "" else None
                        swage_length = float(line[2]) if line[2] != "" else None
                        sDate = datetime.datetime.strptime(line[3], '%m.%d.%Y_%H_%M_%S')
                        cCode = line[4]
                        eCode = line[5]
                        comment = line[6]
                        user = line[7].replace('\r', '').replace('\n', '')

                        endplug_type = line[8]

                    # An earlier version when endplug type wasn't recorded
                    elif len(line) == 8:
                        barcode = line[0].replace('\r', '').replace('\n', '')
                        raw_length = float(line[1]) if line[1] != "" else None
                        swage_length = float(line[2]) if line[2] != "" else None
                        sDate = datetime.datetime.strptime(line[3], '%m.%d.%Y_%H_%M_%S')
                        cCode = line[4]
                        eCode = line[5]
                        comment = line[6]
                        user = line[7].replace('\r', '').replace('\n', '')
                    # This was the very first iteration where there were only 3 things recorded
                    else:
                        barcode = line[0].replace('\r', '').replace('\n', '')
                        comment = line[1]
                        user = line[2].replace('\r', '').replace('\n', '')
                        raw_length = None
                        swage_length = None
                        eCode = None
                        cCode = None
                        # Swager date was stored in the filename in this version
                        try:
                            sDate = datetime.datetime.strptime(filename, '%d.%m.%Y_%H_%M_%S.csv')
                        except ValueError:
                            try:
                                sDate = datetime.datetime.strptime(filename, '%m.%d.%Y_%H_%M_%S.csv')
                            except ValueError:
                                sDate = None

                    tube = Mini_tube()
                    tube.set_ID(barcode)
                    tube.set_ID(barcode)
                    try:
                        error_code = ErrorCodes(int(eCode[0]))
                    except ValueError:
                        error_code = ErrorCodes(0)
                    except TypeError:
                        error_code = ErrorCodes(0)
                    if comment or error_code != 0:
                        tube.new_comment((comment, user, sDate, error_code))
                    tube.swage.add_record(SwageRecord(raw_length=raw_length,
                                                      swage_length=swage_length,
                                                      clean_code=cCode,
                                                      date=sDate,
                                                      user=user))

                    if endplug_type:
                        tube.legacy_data['is_munich'] = endplug_type == "Munich"

                    pickled_filename = str(datetime.datetime.now().timestamp()) + str(
                        random.randrange(100, 999)) + 'swage.tube'

                    if self.logging:
                        print("Pickling swage data for tube", barcode)

                    # file_lock = locks.Lock(pickled_filename)
                    # file_lock.lock()
                    with open(os.path.join(new_data_directory, pickled_filename), "wb") as f:
                        pickle.dump(tube, f)
                    # file_lock.unlock()

            if self.archive:
                os.remove(os.path.join(CSV_directory, filename))

    '''
    This is the tension pickler function that will pickle every tension csv file 
    that is in the specified directory tensionDirectory
    '''

    def pickle_tension(self):
        tension_directory = os.path.join(self.path, "TensionStation")
        CSV_directory = os.path.join(tension_directory, "output")
        for directory in [tension_directory, CSV_directory]:
            if not os.path.isdir(directory):
                # input directories don't exist, just return
                return                
        archive_directory = os.path.join(tension_directory, "archive")
        new_data_directory = os.path.join(self.sMDT_DIR, "new_data")

        for directory in [archive_directory, new_data_directory]:
            if not os.path.isdir(directory):
                os.mkdir(directory)

        for filename in os.listdir(CSV_directory):
            # skip directories
            if os.path.isdir(filename):
                   continue
            # skip .DS_store
            if filename==".DS_Store":
                continue
            with open(os.path.join(CSV_directory, filename)) as CSV_file:
                if self.archive:
                    archive_file = open(os.path.join(archive_directory, filename), 'a')
                for line in CSV_file.readlines():
                    if line in {',\n', ','} or line[0:11] == "Operator ID":
                        continue

                    if self.archive:
                        archive_file.write(line)

                    line = line.split(',')
                    # Check there are 8 columns, else report to terminal
                    if len(line) == 8:
                        user = line[0]
                        date = line[1]
                        barcode = line[2]
                        # not_used   = line[3]
                        # not_used   = line[4]
                        frequency = float(line[5])
                        tension = float(line[6])
                        # not_used   = line[7]
                    # Report to terminal unknown formats
                    else:
                        if self.logging:
                            print("File " + filename + " has a line with unknown format")
                        self.error_files['Tension'].add(filename)
                        continue

                    try:
                        sDate = datetime.datetime.strptime(filename, 'data_%d.%m.%Y_%H_%M_%S.out')
                    except ValueError:
                        try:
                            sDate = datetime.datetime.strptime(filename, 'data_%m.%d.%Y_%H_%M_%S.out')
                        except ValueError:
                            sDate = None

                    # Create tube instance
                    tube = Mini_tube()
                    tube.set_ID(barcode)

                    if self.logging:
                        print("Pickling tension data for tube", barcode)

                    tube.tension.add_record(TensionRecord(tension=tension,
                                                          frequency=frequency,
                                                          date=sDate,
                                                          user=user))

                    pickled_filename = str(datetime.datetime.now().timestamp()) + str(
                        random.randrange(100, 999)) + 'tension.tube'

                    # Lock and write tube instance to pickle file
                    # file_lock = locks.Lock(pickled_filename)
                    # file_lock.lock()
                    with open(os.path.join(new_data_directory, pickled_filename), "wb") as f:
                        pickle.dump(tube, f)
                    # file_lock.unlock()

            if self.archive:
                os.remove(os.path.join(CSV_directory, filename))

    '''
    This is the leak rate pickler function that will pickle every leak rate csv file 
    that is in the specified directory leakDirectory
    '''

    def pickle_leak(self):
        leak_directory = os.path.join(self.path, "LeakStation")
        CSV_directory = os.path.join(self.path, 'LeakDetector')
        for directory in [leak_directory, CSV_directory]:
            if not os.path.isdir(directory):
                # input directories don't exist, just return
                return                
        archive_directory = os.path.join(leak_directory, "archive")
        new_data_directory = os.path.join(self.sMDT_DIR, "new_data")

        for directory in [archive_directory, new_data_directory]:
            if not os.path.isdir(directory):
                os.mkdir(directory)

        for filename in os.listdir(CSV_directory):
            # skip directories
            if os.path.isdir(filename):
                   continue
            # skip .DS_store
            if filename==".DS_Store":
                continue
            with open(os.path.join(CSV_directory, filename)) as CSV_file:
                if self.archive:
                    archive_file = open(os.path.join(archive_directory, filename), 'a')
                for line in CSV_file.readlines():
                    if self.archive:
                        archive_file.write(line)
                    line = line.split('\t')
                    # Check there are 6 columns, else report to terminal
                    if len(line) == 6:
                        try:
                            leak = float(line[0])
                            pressure = line[1]  # Not used
                            pass_fail = line[2]  # Useless
                            date = line[3]
                            time1 = line[4]
                            user = line[5]
                        except ValueError:
                            self.error_files['Leak'].add(filename)
                            continue
                    # Report to terminal unknown formats
                    else:
                        if self.logging:
                            print("File " + filename + " has line with unknown format")
                        self.error_files['Leak'].add(filename)
                        continue

                    try:
                        sDate = datetime.datetime.strptime(date + time1, '%m/%d/%Y%I:%M %p')
                    except ValueError:
                        sDate = None

                    barcode = filename.split('_')[0]

                    # Create tube instance
                    tube = Mini_tube()
                    tube.set_ID(barcode)
                    tube.leak.add_record(LeakRecord(leak_rate=leak,
                                                    date=sDate, user=user))

                    if self.logging:
                        print("Pickling leak data for tube", barcode)

                    pickled_filename = str(datetime.datetime.now().timestamp()) + str(
                        random.randrange(100, 999)) + 'leak.tube'

                    # Lock and write tube instance to pickle file
                    # file_lock = locks.Lock(pickled_filename)
                    # file_lock.lock()
                    with open(os.path.join(new_data_directory, pickled_filename), "wb") as f:
                        pickle.dump(tube, f)
                    # file_lock.unlock()

            if self.archive:
                os.remove(os.path.join(CSV_directory, filename))

    '''
    This is the dark current pickler function that will pickle every dark current csv file 
    that is in the specified directory darkcurrentDirectory
    '''

    def pickle_darkcurrent(self):
        darkcurrent_directory = os.path.join(self.path, "DarkCurrentStation")
        CSV_directory = os.path.join(self.path, 'DarkCurrent', '3015V Dark Current')

        for directory in [darkcurrent_directory, CSV_directory]:
            # input directories don't exist, just return
            if not os.path.isdir(directory): ###TODO figure out why this line doesnt exist before
 
                return
                                                                           
        archive_directory = os.path.join(darkcurrent_directory, "archive")
        new_data_directory = os.path.join(self.sMDT_DIR, "new_data")

        for directory in [archive_directory, new_data_directory]:
            if not os.path.isdir(directory):
                os.mkdir(directory)

        for filename in os.listdir(CSV_directory):
            print(filename)
        for filename in os.listdir(CSV_directory):
            if not filename.endswith("csv"):
                #print("skipping ",filename)
                continue
            print("Opening file ",filename)
            with open(os.path.join(CSV_directory, filename)) as CSV_file:

                tube = Mini_tube()
                barcode = filename.split('.')[0]
                tube.set_ID(barcode)
                if self.archive:
                    archive_file = open(os.path.join(archive_directory, filename), 'a')

                for line in CSV_file.readlines():
                    voltage = None
                    user=""
                    HVchan="" # the channel on the high voltage power supply is not written to the database for now
                    if self.archive:
                        archive_file.write(line)
                    line = line.split(',')
                    # Check there are 2 columns
                    if len(line) > 1:
                        current = float(line[0])
                        date = line[1]
                    if len(line) > 2:
                        voltage = float(line[2])
                    if len(line) > 3:
                        user = line[3].strip()
                    if len(line) > 4:
                        HVchan = line[4].strip()
                    if len(line) < 1 or len(line) > 6:
                        # Report to terminal unknown formats
                        if self.logging:
                            print("File " + filename + " has unknown format")
                        self.error_files['DarkCurrent'].add(filename)
                        continue

                    try:
                        date = date.replace("\n","")
                        date = date.replace(" ","")
                        sDate = datetime.datetime.strptime(date, '%d_%m_%Y_%H_%M_%S')
                    except ValueError:
                        sDate = None

                    tube.dark_current.add_record(DarkCurrentRecord(dark_current=current,
                                                                   date=sDate,
                                                                   voltage=voltage,user=user))
                    if self.logging:
                        print("Pickling dark current data for tube", barcode)

                    pickled_filename = str(datetime.datetime.now().timestamp()) + str(
                        random.randrange(100, 999)) + 'darkcurrent.tube'

                # Lock and write tube instance to pickle file
                # file_lock = locks.Lock(pickled_filename)
                # file_lock.lock()
                with open(os.path.join(new_data_directory, pickled_filename), "wb") as f:
                    pickle.dump(tube, f)
                # file_lock.unlock()

            if self.archive:
                os.remove(os.path.join(CSV_directory, filename))

    '''
    This is the swage pickler function that will pickle every 
    swage csv file that is in the specified directory swagerDirectory
    '''

    def pickle_position(self):
        position_directory = os.path.join(self.path, "PositionStation")
        CSV_directory = os.path.join(position_directory, "PositionData")
        for directory in [position_directory, CSV_directory]:
            if not os.path.isdir(directory):
                # input directories don't exist, just return
                return                

        archive_directory = os.path.join(position_directory, "archive")
        new_data_directory = os.path.join(self.sMDT_DIR, "new_data")

        for directory in [archive_directory, new_data_directory]:
            if not os.path.isdir(directory):
                os.mkdir(directory)

        for filename in os.listdir(CSV_directory):
            # skip directories
            if os.path.isdir(filename):
                   continue
            # skip .DS_store
            if filename==".DS_Store":
                continue
            with open(os.path.join(CSV_directory, filename)) as CSV_file:
                if self.archive:
                    archive_file = open(os.path.join(archive_directory, filename), 'a')
                for line in CSV_file.readlines():
                    if self.archive:
                        archive_file.write(line)
                    line = line.split(',')
                    # Here are the different csv types, there have been 3 versions
                    # The currently used version that includes endplug type 'Protvino' or 'Munich'
                    if len(line) not in [7]:
                        self.error_files['Position'].add(filename)
                        continue
                    if len(line) == 7:
                        barcode = line[0].replace('\r', '').replace('\n', '')
                        chamber = str(line[1]) if line[1] != "" else None
                        row = int(line[2]) if line[2] != "" else None
                        column = int(line[3]) if line[3] != "" else None
                        sDate = datetime.datetime.strptime(line[4], '%m.%d.%Y_%H_%M_%S')
                        comment = line[5]
                        user = line[6].replace('\r', '').replace('\n', '')
                    # Report to terminal unknown formats
                    else:
                        if self.logging:
                            print("File " + filename + " has line with unknown format")
                        self.error_files['Position'].add(filename)
                        continue

                    try:
                        sDate = datetime.datetime.strptime(filename, '%m.%d.%Y_%H_%M_%S_.csv')
                    except ValueError:
                        sDate = None

                    # Create tube instance
                    tube = Mini_tube()
                    tube.set_ID(barcode)

                    if comment:
                        tube.new_comment((comment, user, sDate))

                    if self.logging:
                        print("Pickling position data for tube", barcode)

                    tube.position.add_record(PositionRecord(chamber=chamber,
                                                          row=row,
                                                          column =column,
                                                          date=sDate,
                                                          user=user))

                    pickled_filename = str(datetime.datetime.now().timestamp()) + str(
                        random.randrange(100, 999)) + 'position.tube'

                    # Lock and write tube instance to pickle file
                    # file_lock = locks.Lock(pickled_filename)
                    # file_lock.lock()
                    with open(os.path.join(new_data_directory, pickled_filename), "wb") as f:
                        pickle.dump(tube, f)
                    # file_lock.unlock()

            if self.archive:
                os.remove(os.path.join(CSV_directory, filename))

    def pickle_bentness(self):

        bentness_directory = os.path.join(self.path, "BentnessStation/")
        CSV_directory = os.path.join(bentness_directory, 'BentnessData')
        for directory in [bentness_directory, CSV_directory]:
            if not os.path.isdir(directory):
                # input directories don't exist, just return
                return                
        archive_directory = os.path.join(bentness_directory, "archive")
        new_data_directory = os.path.join(self.sMDT_DIR, "new_data")

        for directory in [archive_directory, new_data_directory]:
            if not os.path.isdir(directory):
                os.mkdir(directory)

        for filename in os.listdir(CSV_directory):
            # skip directories
            if os.path.isdir(filename):
                   continue
            # skip .DS_store
            if filename==".DS_Store":
                continue
            with open(os.path.join(CSV_directory, filename)) as CSV_file:
                
                if self.archive:
                    archive_file = open(os.path.join(archive_directory, filename), 'a')

                for line in CSV_file.readlines():
                    tube = Mini_tube()
                    if self.archive:
                        archive_file.write(line)
                    line = line.split(',')
                    # Check there are 4 or 5 columns (5th column is comment for some of them)
                    if len(line) == 4 or len(line) == 5:
                        barcode = line[0]
                        bentness = float(line[1])
                        date = line[2]
                        user = line[3]
                        #comment = line[4] # Not used right now
                    # Report to terminal unknown formats
                    else:
                        if self.logging:
                            print("File " + filename + " has unknown format")
                        self.error_files['Bentness'].add(filename)
                        continue

                    try:
                        date = date.replace("\n","")
                        sDate = datetime.datetime.strptime(date, '%m.%d.%Y_%H_%M_%S')
                    except ValueError:
                        sDate = None
                        if self.logging:
                            print("File " + filename + " has unknown format")
                        self.error_files['Bentness'].add(filename)                        
                        continue

                    tube.set_ID(barcode)
                    tube.bent.add_record(BentRecord(bentness=bentness, date=sDate, user=user))
                    if self.logging:
                        print("Pickling bentness data for tube", barcode)

                    pickled_filename = str(datetime.datetime.now().timestamp()) + \
                                       str(random.randrange(100, 999)) + 'bentness.tube'

                    # Lock and write tube instance to pickle file
                    # file_lock = locks.Lock(pickled_filename)
                    # file_lock.lock()
                    with open(os.path.join(new_data_directory, pickled_filename), "wb") as f:
                        pickle.dump(tube, f)
                    # file_lock.unlock()

            if self.archive:
                os.remove(os.path.join(CSV_directory, filename))


    def pickle_umich(self):

        umich_directory = os.path.join(self.path, "UMich/")
        CSV_directory = os.path.join(umich_directory, 'UMichData')
        for directory in [umich_directory, CSV_directory]:
            if not os.path.isdir(directory):
                # input directories don't exist, just return
                return                

        archive_directory = os.path.join(umich_directory, "archive")
        new_data_directory = os.path.join(self.sMDT_DIR, "new_data")

        for directory in [archive_directory, new_data_directory]:
            if not os.path.isdir(directory):
                os.mkdir(directory)

        for filename in os.listdir(CSV_directory):
            # skip directories
            if os.path.isdir(filename):
                   continue
            # skip .DS_store
            if filename==".DS_Store":
                continue
            with open(os.path.join(CSV_directory, filename)) as CSV_file:
                
                if self.archive:
                    archive_file = open(os.path.join(archive_directory, filename), 'a')

                for line in CSV_file.readlines():
                    tube = Mini_tube()
                    if self.archive:
                        archive_file.write(line)
                    line = line.split(',')
                    
                    if line[0] == "tubeID":
                        break
                    else:
                        #20 columns in umich.csv
                        barcode = line[0]
                        prod_site = line[1]
                        endplug_type = line[2]
                        first_scan = line[3]
                        bent = float(line[4])
                        flag_endplug = line[5]
                        last_tension_date = line[6]
                        length = float(line[7])
                        frequency = float(line[8])
                        tension = float(line[9])
                        tension_flag = line[10]
                        freq_diff = float(line[11])
                        tens_diff = float(line[12])
                        time_diff = float(line[13])
                        flag_scd_tens = float(line[14])
                        dc_day = line[15]
                        dc = float(line[16])
                        hv_times = float(line[17])
                        dc_flag = line[18]
                        done = line[19]

                    try:
                        first_scan = first_scan.replace("\n","")
                        sDate = datetime.datetime.strptime(first_scan, '%m.%d.%Y_%H_%M_%S')
                    except ValueError:
                        sDate = None
                        if self.logging:
                            print("File " + filename + " has unknown format")
                        self.error_files['UMich'].add(filename)                        
                        continue

                    tube.set_ID(barcode)
                    tube.umich_tension.add_record(UMich_TensionRecord(
                                umich_tension = tension,
                                umich_frequency = frequency,
                                umich_date = last_tension_date,
                                tension_flag = tension_flag,
                                freq_diff = freq_diff,
                                tens_diff = tens_diff,
                                time_diff = time_diff,
                                flag_scd_tension = flag_scd_tens

                    ))

                    tube.umich_dark_current.add_record(UMich_DarkCurrentRecord(
                                umich_dark_current = dc,
                                umich_date = dc_day,
                                dc_flag = dc_flag,
                                hv_time = hv_times
                    ))

                    tube.umich_bent.add_record(UMich_BentRecord(
                                umich_bent = bent
                    ))


                    tube.umich_misc.add_record(UMich_MiscRecord(
                                prod_site = prod_site,
                                endplug_type = endplug_type,
                                first_scan = first_scan,
                                flag_endplug = flag_endplug,
                                length = length,
                                done = done
                    ))

                    if self.logging:
                        print("Pickling umich data for tube", barcode)

                    pickled_filename = str(datetime.datetime.now().timestamp()) + \
                                       str(random.randrange(100, 999)) + 'umich.tube'

                    # Lock and write tube instance to pickle file
                    # file_lock = locks.Lock(pickled_filename)
                    # file_lock.lock()
                    with open(os.path.join(new_data_directory, pickled_filename), "wb") as f:
                        pickle.dump(tube, f)
                    # file_lock.unlock()

            if self.archive:
                os.remove(os.path.join(CSV_directory, filename))


